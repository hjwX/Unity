计算机图像学的第一规律:如果它看起来是对的，那它就是对的

漫反射：
	漫反射光照是对那些被表面随机散射到各个方向的辐射度的建模。在漫反射中视角的方向不重要，应为漫反射的方向是随机的，因此可以认定散射到各个方向的辐射量都是一样的
	但是入射光的角度比较重要
	漫反射光照符合 
	兰伯特定律(Lambert*s law)
	C(diffuse) = (C(light) * m(diffuse))max(0, n*I)
	其中n是表面法线，I是指向光源方向的单位向量， m(diffuse)是材质的漫反射颜色， C(light)光源的颜色
	我们需要防止nI的点积的结果不为负数，可以防止物体被从后面来的光源照亮
	材质的漫反射的颜色m(diffuse)被称为反射率(albedo)通常是用一张纹理来定义
	
	半兰伯特定律
	C(diffuse) = (C(light) * m(diffuse))*(0.5*(n*I) + 0.5)
	通过(0.5*(n*I) + 0.5)我们可以把n*I的结果映射到[0,1]
	这样只是对视觉的一种强化效果
	兰伯特定律有一个问题，在背光的地方模型通常是全黑的，没有明暗的变化，这会使得背光的区域变得像一个平面一样，这样会丢失模型的细节表现
	通过加环境光的方式可以得到不是全黑的效果，还是无法解决背光面明暗一样的缺点
	半兰伯特就是用来解决这个问题的
	
高光反射：
	用于计算那些被镜面反射的光线
	为了计算高光反射，我们需要知道表面法线,视角方向,光源方向,反射方向等
	表面法线我们可以在顶点着色器中计算
	视角方向可由 照相机的位置 和 顶点世界坐标 计算出来
	光源方向 可以由光照信息直接拿到
	反射方向 r = 2(n*I)- I    n是表面法线，I是光源的方向(简单的平行四边形法则计算出)
	
	如果是一面完美光滑的镜子，我们只会看见表面角度恰好合适的反射光。在其他的地方，反射光都会错开我们表面看起来就是黑色的
	但是物体的表面并不是完美的光滑，他们有很多微小的突起，这意味着表面的法线变化会很大
	因此，计算我们的视角方向和反射方向不对应，也可以看到一些反射，偏离的越远就看见的越少
	所以我们可以用 视角的方向 点乘 反射方向 来计算反射光
	
	我们可以用一个属性来控制高光的大小，越光滑的材质可以更好的聚集光线，因此高光越小。
	记为m(gloss)
	所以有Phong模型：
		C(specular) = (C(light) * C(specular))max(0, v*r)^m(gloss)
		v：视角的方向 r:反射光线的方向
	在上述的基础上Blinn提出了一个简单的修改方法来得到类似的效果：
	为了避免计算反射光Blinn模型引入了一个新的向量：
		h = (v + I)/ (|v+I|) 
		计算视角方向和光线方向和的归一
		Blinn模型：
			C(specular) = (C(light) * C(specular))max(0, h*n)^m(gloss)
			Blinn会快于Phong模型 因为V和I是一个常量所以h将是一个常量，但是当V或I不是常量时Phong模型可能快一点
			我们并不能认为Blinn模型比Phong模型更加的 正确 
			但是在实际的运用中Blinn更加的符合
		
		

菲捏尔反射：
	解释：当你站在湖边，低头看脚边的水，会发现水是透明的，反射不是很强烈，但是如果抬头看远处的湖面，会发现水不是透明的，反射的非常的强烈这就是菲涅尔反射
		从数学上来说,当是视线垂直于水平面是反射是最弱的，随着视线的逐渐改变并不在垂直于水平面，夹角逐渐减少，反射就会越来越强
	
	fresnel = F_base + F_scale*((1 - v*n)^power)
	F_base， F_scale， Power都是调参看一抛出自定义
	n是点出的法线方向，v是点到相机的向量 v = _WorldSpaceCameraPos.xyz - worldPos;
	可以用来计算边缘光
	
	
	
	